\documentclass{article}

\begin{document}

\begin{titlepage}
		\noindent{\huge Minimum Fill-In} \\ \\
		Mikkel Gaub, \\ Malthe Ettrup Kirkbro, \\ \& Mads Frederik Madsen	\\ \\
		\hspace{-18pt}
		\textit{June 2, 2017}
		\thispagestyle{empty}
	\end{titlepage}
	\clearpage

	\section{Algorithm}
	The algorithm REFREF is concerned with finding four-cycles and certain substructures in the graph, called moplexes, which are defined as adhering to the following rules: \\

	\begin{description}
		\item[Clique] Every vertex in the moplex must be connected to all other vertices.
		\item[Shared neighbourhood] Every vertex in the moplex must have the same neighbourhood.
		\item[Maximally inclusive] If a vertex can be added to a moplex, without it not being a moplex anymore, that vertex must be included.
	\end{description}

	Furthermore, simplicial moplexes are moplexes where the neighbourhood of the moplex is also a clique.

	As an indicator that an edge will at some point need to be connected to another vertex, markings are used in this algorithm. 
	A maximum of two times k markings are allowed, where k is the number of fill edges in the decision problem.

		\subsection{Kernelization}
		The kernelization algorithm used, described in \cite{kernel}, is split into three phases. Even though the kernelization algorithm is fixed-parameter tractable, it turns out that Phase 1 and 2 can be run with $k=\infty$, and only Phase 3 needs a fixed-parameter $k$, see \cite{polynomial-approx}. The kernelization produces a set of vertices relevant to the minimum fill-in algorithm, set $A$, a set of vertices which are not relevant, set $B$, and a set of essential edge which must be part of solution to the minimum fill-in problem, if one exists of size $k$. 

		The three phases are:
		\begin{description}
			\item[Phase 1] finds independent chordless cycles in the graph, by utilizing the fact that non-chordal graphs does not have a perfect elimination order (PEO). After a chordless cycle is found, it is removed from the graph, in order to find all independent chordless cycles. The vertices in the chordless cycles are added to set $A$, and removed from set $B$.
			\item[Phase 2] finds chordless cycles that share one or more vertices with another cycle. It uses the sets $A$ and $B$ produced by Phase 1, to find cycles that have vertices in both sets. As in phase 1, the vertices in cycles are added to $A$ and removed from $B$.
			\item[Phase 3] finds essential edges for a solution of size $k$, by evaluating all non-edges in the graph. If it finds a non-essential non-edge in a chordless cycle not containing an essential edge, it adds all the vertices of the cycle to $A$ and removes them from $B$, thus ensuring that all chordless cycles are present in $A$.
		\end{description}

		\subsection{Cases} 
		Once the graph has been kernelized, the algorithm is called with an initial k-value. The algorithm then tries to find a solution for the graph with the initial k-value.
		If no solution with that k-value can be found, k is incremented and the algorithm is run again.
		The algorithm is recursively called with a the k-value and in each iteration the first of six actions are performed, where the criteria of that case is met.
		These cases are, in order:
		\begin{description}
			\item[Four-cycle] If a four-cycle exists, the program branches on both possible resolution of the four-cycle.
			\item[Moplex with marked and unmarked vertices] If a moplex containing marked and unmarked vertices exists in the graph, all vertices of the moplex are marked.
			\item[Simplicial moplex with only unmarked edges] If \emph{any} simplicial moplexes containing only unmarked edges, exist in the graph, they are removed.
			\item[Unmarked moplex with a neighbourhood missing only one edge] If a moplex containing only unmarked vertices and has a neighbourhood which is only missing one edge in order to be a clique, the missing edge is added.
			\item[Only marked moplexes] If all moplexes in the graph are marked, the algorithm fails.
			\item[Any unmarked moplex] If there are any unmarked moplexes in the graph, the program branches into two. In one of the cases, every vertex in the moplex is marked. In the other case, every edge missing in the neighbourhood of the moplex is added.
		\end{description}

		At the start of each iteration, the graph is checked for chordality and if k has reached zero, the algorithm increments k and starts over.

	\section{Implementation challenges}

		\subsection{Data structure}
		% Matrix vs adjacencylist

		\subsection{Chordality}

		\subsection{Four-cycles}

		\subsection{Moplexes}

		\subsection{V-star}

	\section{Optimizations}
	The algorithm has been implemented in C++ to allow for greater optimization.

		\subsection{Moplex caching}
		A very large part of the algorithm is in locating every moplex in the graph, since this is used in every case of the algorithm, excluding the case where a four-cycle is found.
		Because the moplexes change fairly little in each iteration of the algorithm, these are cached in order to reduce the amount of time wasted on finding already found moplexes.

		It is accomplished by...

		\subsection{Component splitting}
		Since the graph is possibly divided into smaller kernels by the kernelization algorithm, the problem can potentially reduced to several instances with a lower k each, the performance of the program should greatly increase.

		This is accomplished by running the core of the algorithm on each found component of the graph, with an initial k-value of 0, or the k returned by the kernelization, if only one component exists in the graph.

		\subsection{Subgraphs}
		Many functions used by the algorithm requires subgraphs to be considered, such as the kernelization and the deletion of simplicial moplexes.
		Since the algorithm is depth-first, meaning each branch is explored exhaustively before the next branch is considered, the changes made must be easily reversible.
		Since copying or deleting and recreating the graph is expensive, a cheap way to specificy which parts of the graph are currently "active" would be useful.
		This is a accomplished with a boolean value for each vertex, indicating whether or not it should be regarded.

		\subsection{Minimum cardinality search}

	\section{Failed optimizations}

		\subsection{Set functions}

		\subsection{Graph squashing}

	\section{Comparison}

	\section{Conclusion}

	\pagebreak
	\addcontentsline{toc}{section}{References}	
	\bibliographystyle{plain}
	\begin{thebibliography}{99}

		\bibitem{kernel}
		Kaplan, H., Shamir, R. and Tarjan, R. E. 
		\textit{Tractability of Parameterized Completion Problems on Chordal, Strongly Chordal, and Proper Interval Graphs}. 
		SIAM J. COMPUT., Vol. 28, No. 5, pp. 1906--1922

		\bibitem{polynomial-approx}
		Natanzon, A., Shamir, A., Sharan R.,
		\textit{A Polynomial Approximation Algorithm for the Minimum Fill-In Problem}. 
 		SIAM J. COMPUT., Vol. 30, No. 4, pp. 1067--1079
	\end{thebibliography}

	\clearpage

\end{document}